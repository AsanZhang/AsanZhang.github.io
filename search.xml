<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《深入理解Java7：核心技术与最佳实践》读书笔记（二）]]></title>
      <url>%2F2017%2F02%2F15%2Funderstanding-Java7-reading-notes-2%2F</url>
      <content type="text"><![CDATA[这一篇为《深入理解Java7：核心技术与最佳实践》的第二篇读书笔记，主要记录的是Java语言的动态性。我们知道Java本身是一种静态类型的高级编程语言，即其源代码在编译时需要进行类型检查。我们这里所说的动态性不是指类型上的，而是使用方式上的动态。为了对Java语言的动态性有一个全面的了解，此处所涉及的内容不仅有Java7的新特性，还包括了之前版本就有的特性，如对脚本语言支持的API、反射API和动态代理等。 脚本语言支持API JavaScript、JRuby和Groovy等许多流行脚本语言已经尅一在Java虚拟机上运行，他们Java语言的交互是通过Java提供的脚本语言API进行的，同时通过此API，Java程序和脚本之间可以进行双向的方法调用和数据传递。脚本语言API在Java标准API中是javax.script包，在Java 6引入。； 一段脚本的执行需要由此脚本语言对应的脚本引擎来完成，而Java中已经定义了脚本引擎的注册和查找机制。一般地，可以通过以下方式获得脚本引擎：首先创建一个脚本引擎管理器javax.script.ScriptEngineManager对象，再通过管理器查找所需的脚本引擎。查找脚本管理引擎的方式有如下3种，以获取JavaScript引擎为例： javax.script.ScriptEngineManager.getEngineByName(&quot;JavaScript&quot;)，通过引擎名称获取； javax.script.ScriptEngineManager.getEngineByExtension(&quot;js&quot;)，通过文件扩展名获取； javax.script.ScriptEngineManager.getEngineByMimeType(&quot;text/javascript&quot;)，通过MIME类型获取。 Java程序和脚本之间的数据双向传递是通过语言绑定对象实现的，所谓语言绑定对象就是一个简单的哈希表，数据为这个哈希表的条目，一个简单的名值对。下面的代码实现了Java程序和脚本语言的双向数据传递： 123456789101112public void useDefaultBinding() &#123; ScriptEngine jsEngine = getJsEngine(); jsEngine.put("name", "Jay Chou"); try &#123; jsEngine.eval("var message = 'Hello,'+name;"); jsEngine.eval("println('jsEngine: '+message)"); Object obj = jsEngine.get("message"); System.out.println("Java lang: " + obj); &#125; catch (ScriptException e) &#123; e.printStackTrace(); &#125;&#125; 实现了javax.script.Invocable接口的脚本引擎可以调用脚本的顶层方法（使用Invocable的invokeFunction），也可以调用对象中的成员方法（使用Invocable的invokeMethod），下面的代码片段展示了Java程序和脚本之间双向方法调用： 12345678910// getGreeting是对象obj的成员方法，在Java程序中调用时需把这个对象作为参数传入public void invokeMethod() throws ScriptException, NoSuchMethodException&#123; ScriptEngine jsEngine = getJsEngine(); String scriptText = "var obj = &#123;getGreeting : function(name)&#123;return 'Hello，' + name;&#125;&#125;;"; jsEngine.eval(scriptText); Invocable invocable = (Invocable)jsEngine; Object scope = jsEngine.get("obj"); Object result = invocable.invokeMethod(scope, "getGreeting", "Jay Chou"); System.out.println(result);&#125; 在有些脚本引擎中，可以在Java程序中定义接口，而在脚本中实现接口： 123456789// getGreeting为Java定义的接口Greet中的一个方法，其实现由脚本来完成public void userInterface() throws ScriptException&#123; ScriptEngine jsEngine = getJsEngine(); String scriptText = "function getGreeting(name)&#123; return 'Hello，' + name;&#125;"; jsEngine.eval(scriptText); Invocable invocable = (Invocable)jsEngine; Greet gteet = invocable.getInterface(Greet.class); System.out.println(gteet.getGreeting("Jay Chou"));&#125; 运行时动态特性之反射 反射API的重要使用场景之一就是要调用的方法或要操作的域的名称按照某种规律变化的时候； 对于嵌套类构造方法的获取，需要区分静态和非静态。静态的操作与一般的无异，而非静态的嵌套类对象由于持有一个指向包含它的外部类对象的引用，所以在获取其构造方法时，参数列表第一个参数类型必须为外部类的Class对象： 123456789101112131415161718192021222324public class ConstructorUsage &#123; static class StaticNestedClass &#123; public StaticNestedClass(String name) &#123; //do something &#125; &#125; class NestedClass &#123; public NestedClass(int age) &#123; //do something &#125; &#125; public void useNestedClassConstructor() throws Exception &#123; Constructor&lt;StaticNestedClass&gt; sncc = StaticNestedClass.class.getDeclaredConstructor(String.class); sncc.newInstance("Jay Chou"); //非静态嵌套类的构造方法获取 Constructor&lt;NestedClass&gt; nc = NestedClass.class.getDeclaredConstructor(ConstructorUsage.class, int.class); NestedClass ncIns = nc.newInstance(this, 5); &#125;&#125; 反射API可以获取到类中公开的静态域和实例域，私有的无法获取也无法操作。体现在代码中，使用静态域时不需要提供具体的实例： 123456789// count和name分别为类FieldContainer中声明的静态域和实例域public void useField() throws Exception&#123; Field fieldCount = FieldContainer.class.getDeclaredFeild("count"); fieldCount.set(null, 3); Field fieldName = FieldContainer.class.getDeclaredFeild("name"); FieldContainer fieldContainer = new FieldContainer(); fieldName.set(fieldContainer, "Jay Chou");&#125; 反射API不仅可以获取类中的公共方法，也可以获得私有的方法： 12345678910public void useMethod()&#123; MethodContainer mc = new MethodContainer(); Method publicMethod = MethodContainer.class.getDeclaredMethod("publicMethod"); publicMethod.invoke(mc); Method privateMethod = MethodContainer.class.getDeclaredMethod("privateMethod"); // 设置访问权限，使得私有方法也可以被访问到 privateMethod.setAccessible(true); privateMethod.invoke(mc);&#125; 此例中，通过反射API绕过了Java中默认的访问控制权限，Constructor、Field和Method都继承自java.lang.reflect.AccessibleObject，其中的方法setAccessible可以用来设置是否绕开默认权限检查； 最佳实践：在使用invoke调用方法时，如果方法本身抛出异常，invoke方法会抛出InvocationTargetException，当捕获了这个异常即通过方法getCause来获得真正的异常信息，方便调试；值得一提的是，Java 7为所有与反射操作有关的异常添加了一个新的父类java.lang.ReflaciveOperationException，在处理与反射有关的异常时可以直接捕获这个异常，而在Java 7之前需要分别捕获。 运行时动态特性之动态代理 动态代理只支持对接口的代理，所以使用动态代理需要两个元素即可： 第一个是被代理的接口，第二个是处理接口方法调用的java.lang.reflect.InvocationHandler接口。举个栗子： 12345678910111213141516171819202122232425262728293031323334353637public class UseProxy &#123; // 处理接口方法调用的invocationHandler static class PrintInvocationHandler implements InvocationHandler&#123; private Object targetObj; public PrintInvocationHandler(Object targetObj) &#123; this.targetObj = targetObj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("&gt;&gt;&gt;&gt;&gt; 调用方法" + method.getName()); Object result = method.invoke(targetObj, args); return "++++++ " + result + " ++++++"; &#125; &#125; public static void main(String[] args) &#123; // 原始的方法调用接收者对象，方便在invocationHandler中执行原始调用 DoSomeServiceImpl doSomeServiceImpl = new DoSomeServiceImpl(); /** * 代理类实现了指定的接口，并通过invocationHandler对目标类中的接口实现方法进行了增强 */ DoSomeService proxyInstance = (DoSomeService)Proxy.newProxyInstance(DoSomeServiceImpl.class.getClassLoader(), new Class[]&#123;DoSomeService.class&#125;, new PrintInvocationHandler(doSomeServiceImpl)); String res = proxyInstance.doSomeThing("Python"); /** * &gt;&gt;&gt;&gt;&gt; 调用方法doSomeThing * ++++++ Python, Hello World! ++++++ */ System.out.println(res); &#125;&#125; 如果被代理的接口不是公开的，那么被代理的接口需要和实现动态代理的代码在同一个包中； 最佳实践：当代理类实现多个接口时，在创建代理类时接口排列顺序尤为重要。即对于相同的一组接口，不同的接口排列顺序所产生的代理类也是不同的。相同排列的接口产生的代理类只会被创建一次，并且创建一次会被缓存起来。如果多个接口中都存在声明类型相同的方法，那么排列顺序中最先出现的接口方法会被选择。 对动态语言的支持 Java 7中的动态语言支持主要是在虚拟机规范的层次上修改的，如新增字节码指令invokedynamic。但是在 代码和API层次上也新增了标准库APIjava.lang.invoke包； 方法句柄是Java中对方法、构造方法和域的一种可执行应用，通过方法句柄可以动态指定方法的接收者 ： 12345678910111213141516171819202122232425262728import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup;public class MethodHandleTest &#123; static class ClassA &#123; public void println(String s) &#123; System.out.println(s); &#125; &#125; public static void main(String[] args) throws Throwable &#123; Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA(); // 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。 getPrintlnMH(obj).invokeExact("Hello Java!"); &#125; private static MethodHandle getPrintlnMH(Object reveiver) throws Throwable &#123; // MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。 MethodType mt = MethodType.methodType(void.class, String.class); // lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。 /** * 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的， * 代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递， 现在提供了bindTo()方法来完成这件事情。 */ return lookup().findVirtual(reveiver.getClass(), "println", mt).bindTo(reveiver); &#125;&#125; 方法getPrintlnMH()中实际上是模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上的，而是通过一个具体方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。 参考资料 解析JDK 7的动态类型语言支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017-02技术文章摘要总结]]></title>
      <url>%2F2017%2F02%2F13%2F2017-02-essay-of-tech-articles%2F</url>
      <content type="text"><![CDATA[此为2017年2月份看过的技术文章的总结与感悟。 2017-02-13 晴 PM2.5:127 @杭州 99%的人都理解错了HTTP中GET与POST的区别 HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议，是数据在万维网中传输的“行为准则”； HTTP中的GET和POST本质上就是TCP连接，是两种不同的传输数据的方式，本质上无差别； 由于浏览器/服务器的对请求处理的限制，GET和POST在应用中体现出一些不同，如GET请求在URL中传送的参数是有长度限制的，而POST则没有； GET请求产生一个数据包：对于GET方式的请求，浏览器会把HTTP header和data一并发送出去，服务器响应200 OK（返回数据）； POST产生两个TCP数据包：对于POST方式的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK（返回数据）。 GET与POST都有自己的语义，不能随便混用； 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点； 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 2017-02-16 多云 PM2.5:65 @杭州 登录工程：传统 Web 应用中的身份验证技术传统Web应用中身份验证最佳实践 只在鉴权请求中发送一次用户名和密码凭据； 成功凭据之后，由服务器生成代表用户“身份的 Cookie”（或同时以名值对的形式存储在NoSQL数据库中），发送给客户端； 客户端在后续请求中携带上一步中收到的 “身份 Cookie”； 服务器解密”身份 Cookie”（或从NoSQL数据库中获取身份信息），并对需要访问的资源予以授权。 传统Web应用中的单点登录 在便利用户的同时，也期待各个子系统仍拥有独立用户身份、独立管理和运维的灵活性，因此可引入独立的鉴权子站点； 当用户到达业务站点A时，被重定向到鉴权站点；登录成功之后，用户被重定向回到业务站点 A、同时附加一个指示“已有用户登录”的令牌串（token）——此时业务站点A使用令牌串，在服务器端从鉴权子站点查询并记录当前已登录的用户。当用户到达业务站点B时，执行相同流程，由于已有用户登录，所以用户登录的过程会被自动省略。 2017-02-17 阴 PM2.5:80 @杭州 登录工程：现代 Web 应用的典型身份验证需求 我们通常假设用户不信任浏览器，用户通过与服务器建立的临时浏览器会话完成操作。会话开始时，用户被重定向到特定页面进行登录。登录完成后，用户通过持续与服务器交互来延续临时会话的时长；一旦用户一段时间不与服务器交互，则他的会话很快就会过期（被服务器强制登出）； 安装在移动设备中的应用程序更受用户信任；登录时将用户重定向到一个网页去登录的做法，并不能提供很好的用户体验——更重要的是，用户在使用移动设备时，时间是碎片化的。我们无法要求用户必须在特定时间内完成操作，也就基本没有会话的概念：我们需要找到一种能够安全地在设备中相对持久地存储用户凭据的方法，并且Web应用服务器可能需要配合这种方式来完成鉴权； 在注册时，越来越多的网站要求用户提供电子邮箱地址或者手机号码，有的网站还支持让用户以多种方式登录。比如，提供一种让用户在使用了一种方式注册之后，还能绑定其他登录方式的功能。绑定完成之后，用户可以选用他喜欢的登录方式。它隐含了一个网站与用户共同的认知：联系方式的拥有者即为用户本人，这种“从属”关系能够用于证实用户的身份。当用户下次在注册新网站时遇到“邮件地址已被注册”，或者“手机号已被注册”的时候，基本可以确定自己曾经注册过这个网站了； 登录过程中所支持的联系方式也呈现出多样性。电子邮件服务在很多场景中逐渐被形式多样的其他联系方式（比如手机、微信等）所取代，不少人根本没有使用邮件的习惯，如果网站只提供邮箱注册的途径，有时候还会遭到那些不经常使用电子邮箱的用户的反感； 上文中提到的“从属”关系不光可以帮助用户判断自己是否注册过一个网站，也可以帮助网站在忘记密码时进行临时认证，从而帮助用户完成新密码的设置。如果将这种从属关系用于正常登录过程中的进一步验证，就构成了双因子鉴权，一种增强型的登录过程； 从整个企业的业务模式（例如网易门户和网易邮箱），到某项业务的具体流程（例如京东订单和京东支付），再到某个流程中的具体步骤（例如短信验证与支付扣款），“服务”这一概念越来越轻量级，于是人们不得不创造了“微服务”这个新的品类词汇来拓展认知空间； 在互联网Web应用中，授权的范畴也包含一个很小的公有部分，是各个业务系统所共有的：即用户状态。我们希望在各业务子系统之间共享用户状态：用户被锁定之后，他在所有业务系统都被锁定；用户被注销之后，所有业务系统中有关他的数据都被封存。另外在多个业务系统中，还可能会共用用户的基本资料和偏好设置等数据。这样，开发一个“用户”系统的想法也就应运而生了。由于与用户的状态等基础信息的关系很紧密，登录与用户系统之间的集成是很自然的，将登录子系统直接作为这个用户系统的一部分也不失为一种不错的实践； 如果识别用户这一需求能够在不需要用户注册的前提下搞定，岂不两全齐美？基于第三方身份提供方的接口来识别已经在其他平台注册的用户，并将其转化为自己应用中的用户，这种方式完全可行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《深入理解Java7：核心技术与最佳实践》读书笔记（一）]]></title>
      <url>%2F2017%2F02%2F09%2Funderstanding-Java7-reading-notes-1%2F</url>
      <content type="text"><![CDATA[Java 7是至Java 6以来最大幅度的语法更新，“他山之石，可以攻玉”，了解Java 7的新特性和底层相关原理对于自己的编码工作和实践想必会大有裨益。此文为《深入理解Java7：核心技术与最佳实践》一书的读书笔记，此为第一篇，主要记录Java7新特性。 在switch语句中使用字符串 在Java 7之前，switch语句中的条件表达式只能使用和整数兼容的类型：char、byte、short和int，以及这些基本类型对应的包装类型Character、Byte、Short和Integer； 在Java 7中，在上述的支持外，还新增了对字符串String类型的支持，即可以在switch语句的表达式中使用字符串参数，在case子句中使用字符串常量，一个简单用法如下： 12345678910111213141516171819/*** 根据性别向姓名后加上称谓*/public class Titile&#123; public String generate(String name, String gender)&#123; String title = ""; switch(gender)&#123; case "男": title = name + "先生"; break; case "女": title = name + "女士"; break; default: title = name; &#125; return title; &#125;&#125; switch语句中的表达式和case子句的值均不可为null，如果为null前者会在运行时抛出NullPointerException，后者则直接无法通过编译； switch语句要求各个其case子句的值不能相同，这点对字符串也适用。Java中字符串是可以包含Unioncode转义字符的，而Java编译器对case相同值的检查是在对相关Java源代码进行词法转换后进行的，所以如果Java源代码中看到的值是不一样的，但是经词法处理后却是一样的，这样就会造成编译错误； 实现原理：这个新特性是在编译器级别上实现，在JVM和字节码上仍是原来的实现方式，即只能使用和整数兼容的类型。虽然在Java源代码中switch使用了字符串，但是编译器会根据源代码的含义来进行转换，将字符串转换成与整数类型兼容的格式； 最佳实践：对于switch语句，如果在代码中有多个地方来枚举字符串，就考虑使用枚举类型进行替换。 数字字面量的增强与改进 在编程语言中，字面量（literal）指的是在源代码中直接表示的一个固定值。 在之前八/十/十六进制整数字面量的基础上，Java7新增二进制整数字面量，通过在数字前面添加“0b”或“0B”来表示；举个栗子： 1234567import static java.lang.System.out;public class BinaryIntegerLiteral&#123; public void display()&#123; out.println(0b001001);//输出数字 9 out.println(0B001110);//输出数字 14 &#125;&#125; 优化长数字字面量的表示，使用任意多个下划线的方式对长数字字面量进行分割，但是下划线只能用在数字之间。举个栗子： 12345678import static java.lang.System.out;public class underscore&#123; public void display()&#123; out.println(1_500___000);//输出数字 1500000 out.println(5_6.3_4);//输出数字 56.34 out.println(89_____3_1);//输出数字 8931 &#125;&#125; 异常处理 异常分为受检异常（checked exception）和不受检异常（unchecked exception），是否受检是相对于编译器而言的； 由于编译器需要检查异常的合法性，受检异常所在方法的使用者则必须进行try-catch-finally处理，这个时候受检异常就成为API的一部分，而不受检异常则不会有这样的情况； 自定义异常的最佳实践： 程序中的自定义异常要自己的层次结构，最好与程序的抽象层次（如典型3层web应用：展示层、业务层和数据访问层）相对应； 程序中出现的各种错误都需应该一个异常类与之对应，每一个抽象层次都应该定义一个基本异常类； 异常在跨越程序抽象层次边界时，异常包装成上一个调用栈（或抽象层次）的基本异常类，以保证异常只出现其对应的抽象层次中； 异常要包含足够的信息，可以通过添加所需的域或方法来实现； 适当的区分异常和错误提示：异常是程序中的错误，而错误则是用户不当操作程序引起的，要避免让用户看到与异常相关的信息。 处理异常的最佳实践： 如果抛出异常的代码处于程序抽象层次的边界，则要将当前异常捕获后包装成上一个调用栈的异常类； 如果从异常中恢复有合理的办法存在，则也可以捕获异常并进行恢复异常的操作； 在try-catch-finally语句块中，try语句和finally语句中都可能抛出异常，并且如果两者都抛出了异常，则finally语句的异常会先于try语句的异常向上抛出，从而try语句块抛出的异常则会消失，不会再向上传递。这个是时候可以选择保留try语句的异常或者使用Java7的新特性调用public final void addSuppressed(Throwable exception)将try语句块中的异常放入异常栈中，一起向上传递； Java7中一个catch子句可以捕获多个异常，多个异常之间使用|分隔且同一个catch子句多个异常参数之间不能有继承关系，举个栗子： 123456789101112public class ExceptionHandler&#123; public void handle()&#123; ExceptionThrower thrower = new ExceptionThrower(); try&#123; thrower.manyExceptions(); &#125;catch(ExceptionA | ExceptionB ab)&#123; //do somethings &#125;catch(ExceptionC c)&#123; //do somethings &#125; &#125;&#125; 关于一个catch子句中的异常类型不能出现一个是另一个子类的情况，实际上涉及异常的内部实现方式，下面的栗子就可以编译通过： 123456789public void testSequence()&#123; try&#123; Integer.parseInt("hello"); &#125; //NumberFormatException是RuntimeException子类 catch(NumberFormatException | RuntimeException e)&#123; //do somethings &#125;&#125; 如果上述catch子句中异常声明调换下位置则不能够编译通过； 在Java7中，对抛出的异常类型做了更加精确的判断，举个栗子： 12345678910111213public class PreciseThrwoUse&#123; public void testThrow() throws ExceptionA&#123; try&#123; throw new ExceptionASub1(); &#125;catch(ExceptionA e1)&#123;//编译器可以准确知道e1是ExceptionASub1类型的 try&#123; throw e1 &#125;catch(ExceptionASub2 e2)&#123;//此处试图将e1以ExceptionASub2类型捕获，编译错误 //do somethings &#125; &#125; &#125;&#125; 而在Java7之前上面的代码是可以编译通过的。 增加try-with-resources语句 在进行资源操作时很可能出现各种异常，而资源管理要求不管操作是否成功，资源都要被正确释放，即通过try-catch-finally语句块的finally语句进行资源释放操作。为了减少代码冗余，Java7对try语句进行了增强： 123456789101112public class ResourcesBasicUsage&#123; public String readFile(String path) thrwos IOException&#123; try(BufferedReader reader = new BufferedReader(new FileReader(path)))&#123; StringBuilder builder = new StringBuilder(); String line = null; while((line = reader.readLine()) != null)&#123; builder.append(line).append(String.format("%n")); &#125; return builder.toString(); &#125; &#125;&#125; 上面的代码并不需要使用finally来确保正确释放资源，因为这是自动完成的。当然这是有前提的，资源对应的类需要实现java.lang.AutoCloseable接口，否则会出现编译错误。 如果资源在初始化时或try语句出现异常，而资源释放正常执行，则try的异常则会抛出； 如果try语句和资源释放都出现了异常，则最终抛出的是try语句的异常，而在释放资源的异常则会通过Throwable.addSuppressed方法作为被抑制的异常添加进去。 优化变长参数的方法调用 在Java7之前，向可变参数方法的参数类型如果是non-refiable的，比如泛型，则会产生警告信息； 在Java7中对上述情况作出了改进，可以在参数可变的方法或构造方法上使用注解@SasfeVarargs，但前提是这些方法必须是static或final的，并且你可以确定在这些方法实现中对泛型参数的处理不会引发类型安全问。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何手动下载SPRING-FRAMEWORK的jars]]></title>
      <url>%2F2016%2F06%2F05%2Fhow-download-SPRING-FRAMEWORK-jars-manually%2F</url>
      <content type="text"><![CDATA[在Maven和Gradle等构建方式盛行的今天，有些童鞋（比如我，害羞脸）还是很钟情于手动下载项目中所需要和依赖的jars，今天就和有这方面需求的童鞋分享下如何手动下载Spring-Framework中的jars，当然仅仅是Spring的核心jars，不含第三方的依赖。 打开Spring的官网你可以直接输入网址，也可以使用搜索引擎，whatever，进入Spring的官网，会打开如下的页面： 选择SPRING-FRAMEWORK点击官网首页的PROJECTS后，进入如下的项目选择页面，我们选择SPRING-FRAMEWORK项目，如下图操作： 点击图中红色方框即可进入SPRING-FRAMEWORK项目主页。 进入SPRING-FRAMEWORK的GitHub主页我们在Spring官网中SPRING-FRAMEWORK的主页，点击GitHub的图标以进入该项目的GitHub主页： 打开SPRING-FRAMEWORK的的Wiki 在该页面点击上方的Wiki栏目，以进入下一步骤。 找到下载Spring包 点击上图红框中的链接，就可以进入到下载Spring包的介绍页面，该页面介绍了多种获取Spring jars的多种方式，当然包括手动下载方式。 寻找Spring jars分发仓库入口上一步操作后我们就到了载Spring包的介绍页面，将页面滚动到尾部，在以Manually downloading Spring distributions为标题的这段文字中点击下图中的网址链接： Spring jars分发仓库上一步后我们便到了Spring jars分发仓库，这里是各种开源项目的一个jars的分发仓库，如下图，点击侧边栏的Artifacts： 包浏览树上一步的操作是为了打开如下页面： 选择springframework节点这一步无需多言，直接看图： 下载springframework的jars点击springframework的子节点spring，这个节点下有SPRINGFRAMEWORK的各个发行版本，点击选择你想要下载的版本，然后点击右边的Download按钮即可下载： 以上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS下通过Homebrew安装MySQL]]></title>
      <url>%2F2016%2F05%2F17%2FmacOS-homebrew-install-MySQL%2F</url>
      <content type="text"><![CDATA[macOS有了Homebrew这样的软件包管理工具后，管理软件就变得十分的方便。今天和大家分享一下如何在Mac上安装MySQL数据库，以及碰到一些坑后要怎么解决，我安装的MySQL版本是5.7.12。 使用Homebrew安装执行如下命令查找MySQL，会列出很多项: 1brew search mysql 安装的时候选择mysql这一项，执行命令： 1brew install mysql 耐心等待片刻等待安装成功，然后开启MySQL服务： 1brew services start mysql 如果安装完MySQL后出现问题，想要卸载可以依次执行以下的命令： 12345brew remove mysqlbrew cleanuplaunchctl unload -w ~/Library/LaunchAgents/com.mysql.mysqld.plistrm ~/Library/LaunchAgents/com.mysql.mysqld.plistsudo rm -rf /usr/local/var/mysql 配置数据库Mac OSX下默认是不用通过my.cnf来配置的，默认配置已经完全可以使你方便的使用MySQL了。但是，如果你觉得不折腾心痒难耐，可以使用如下命令： 1mysqld --help --verbose | more 你会看到如下一段描述，表示配置文件默认读取顺序： Default options are read from the following files in the given order:/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf 但是通常这些位置是没有配置文件的, 所以要自己建一个，通过下面这条命令可以找到my.cnf样例： 1ls $(brew --prefix mysql)/support-files/my-* 把找到的样例拷贝到第一个默认目录： 1cp /usr/local/opt/mysql/support-files/my-default.cnf /etc/my.cnf 这样，以后按需修改即可。 修改密码校验的等级MySQL从5.6.6开始，开始可以使用validate_password插件来校验密码，当你安装这个插件后（对，我就手贱的安装了），试图要降低安全等级时会报错： 1ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 这时我们执行命令： 1mysql&gt; SHOW VARIABLES LIKE &apos;validate_password%&apos;; 可以看到 +————————————–+——–+| Variable_name | Value |+————————————–+——–+| validate_password_dictionary_file | || validate_password_length | 8 || validate_password_mixed_case_count | 1 || validate_password_number_count | 1 || validate_password_policy | MEDIUM || validate_password_special_char_count | 1 |+————————————–+——–+ 其默认的安全等级是MEDIUM，我们可以把它改变为LOW: 1mysql&gt; SET GLOBAL validate_password_policy=LOW; 这个更为详细的可以参看 Change MySQL password policy level以上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[推送Git项目到多个远程仓库]]></title>
      <url>%2F2016%2F05%2F14%2Fgit-push-to-multiple-repositories%2F</url>
      <content type="text"><![CDATA[最近一直在学习和使用Git作为版本控制系统，并同时使用GitHub和Coding作为自用项目的远程仓库来托管代码。自从Google被墙后，心里就对使用域外的互联网服务产生了阴影，总担心有一天GitHub也会被墙，所有就萌生了是不是可以把自己本地代码同时推送到两个远程仓库的想法，这样可以在一次commit and push把自己的代码同时推送到GitHub和Coding。于是经过一翻Google（没错，就是Google你没有看错）和摸索，终于得偿所愿，现在把自己的做法分享一下。 选择SSH克隆远程仓库虽然GitHub官方推荐使用HTTPS URLs: The https:// clone URLs are available on all repositories, public and private. These URLs work everywhere–even if you are behind a firewall or proxy. 但还是强烈推荐实用SSH的方式来完成和远程仓库连接过程中的认证，这样不用每次都输入用户名和密码（如果你有更好办法，欢迎留言），变的十分方便。具体的可以在你远程仓库选择SSH URL的方式，举个GitHub的栗子： 克隆远程仓库到工作目录作为一个Java developer，平时经常使用的IDE是Eclipse（用过一段时间的IntelliJ IDEA，感觉很别扭，可能是还没习惯，反正没再继续使用，也许将来会使用，谁知道呢），所以我这里将通过Eclipse来把远程仓库克隆到我本地工作目录。拷贝SSH URL（我这里使用Coding来克隆，主要是因为其在国内速度快，后面将添加GitHub作为另一个远程仓库。成功添加GitHub后便可以只从Coding拉取代码，而同时向Coding和GitHub推送代码了，这样既保证拉取时有足够快的速度又可以备份一份代码到GitHib，简直简直爽到没朋友啊。）后，粘贴到Eclipse中，使用Import Projects form Git导入项目： 粘贴后不需要进行任何设置，直接Next&gt;进行后面的项目导入操作，这里不再赘述。 添加另一个远程仓库由于上面我是从Coding上克隆仓库到工作目录的，所以这里我将演示如何再添加GitHub作为另一个远程仓库。如果已经配置好了SSH验证方式，并在GitHub添加了你SSH Key，在终端（Windows下你可能使用的是GitBash）进入你当前项目工作目录下的.git目录并查看： 1234567891011~/your_working_dir/.git on git:master o$ ll-rw-r--r-- 1 asan staff 119 5 14 15:22 FETCH_HEAD-rw-r--r-- 1 asan staff 23 5 14 15:22 HEADdrwxr-xr-x 2 asan staff 68 5 14 15:22 branches-rw-r--r-- 1 asan staff 281 5 14 15:22 configdrwxr-xr-x 2 asan staff 68 5 14 15:22 hooks-rw-r--r-- 1 asan staff 4064 5 14 15:23 indexdrwxr-xr-x 4 asan staff 136 5 14 15:22 logsdrwxr-xr-x 4 asan staff 136 5 14 15:22 objectsdrwxr-xr-x 5 asan staff 170 5 14 15:22 refs 用vim打开文件config，可以看到 1234567891011121314151617$ vi config[core] repositoryformatversion = 0 filemode = true logallrefupdates = true precomposeunicode = true[remote "origin"] url = git@git.coding.net:username/your_project.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master~~~"config" 11L, 281C 这时我们在[remote &quot;origin&quot;]节点下添加GitHub的克隆SSH URL，如下： 123456789101112131415161718$ vi config[core] repositoryformatversion = 0 filemode = true logallrefupdates = true precomposeunicode = true[remote "origin"] url = git@git.coding.net:username/your_project.git url = git@github.com:username/your_project.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master~~~"config" 11L, 281C 保存并退出vim，当然，使用命令行也可以直接添加，命令格式如下： 1git remote set-url --add origin git@github.com:username/your_project.git 此时我们执行命令git remote show origin会发现，后来添加的远程仓库已经是另外一个Push URL了： 123456789101112$ git remote show origin* remote origin Fetch URL: git@git.coding.net:username/your_project.git Push URL: git@git.coding.net:username/your_project.git Push URL: git@github.com:username/your_project.git HEAD branch: master Remote branch: master tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 至此，我们就实现了推送Git项目到多个远程仓库，只从Coding拉取代码，而同时向Coding和GitHub推送代码。 附赠在Eclipse中commit代码时，如果打开的是一个Staging View而不是一个对话框，则可以按附图中的方法进行设置：把设置项Useing Staging View to commit instead of Commit Dialog前的对勾去掉。但这个设置可能仅对Mac OSX下的Eclipse有用，因为我在Windows版本的Eclipse中并没有找到对应的设置，当然两个平台都是最新版本的Eclipse Mars，希望对碰到类似问题的童鞋有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git拉取命令报错]]></title>
      <url>%2F2016%2F05%2F09%2Fgit-pull-error%2F</url>
      <content type="text"><![CDATA[Git拉取命令报错在使用git过程中，更新操作是很常见的一种操作。如果当本地的文件修改过后，和远程仓库的文件不一致了，此时再进行更新操作就可能会产生错误Your local changes to the following files would be overwritten by merge。下面是我在更新Hexo主题时出现的： 那么当出现了上述的问题时，我们应该怎么办呢？一般根据你的实际情况作如下操作： 保留本地版本同时更新这种情形适合希望保留生产服务器上所做的改动，仅仅并入新配置项，则可以依次如下操作： 123git stashgit pullgit stash pop 然后可以使用git diff -w file来确认代码自动合并的情况。 舍弃本地版本同时更新这种情形适合希望用远程仓库中的文件完全覆盖本地工作版本，并舍弃本地版本，则可以依次如下操作： 12git reset --hard HEAD^git pull 其中git reset --hard HEAD^是针对版本，如果想丢弃一个文件的所有改动，可使用 1git checkout -- file]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oracle事务锁导致事务无法提交的问题]]></title>
      <url>%2F2016%2F04%2F07%2Foracledb-transaction-lock-issue%2F</url>
      <content type="text"><![CDATA[今天在修改bug的过程中，一条更新数据的sql执行怎么也执行不了，进入貌似“排队”的情况，一直处于等待的状态，第一直觉是事务锁起到坏作用，后在项目组高手的协助下找到了原因，是数据被锁住了。一般查询是否被锁住可以做如下操作： 以系统数据库管理员的身份登录12345--无连接启动sqlplussqlplus /nolog;--以sysdba的身份连接数据库conn /as sysdba; 查看被锁的数据对象12345--查询被锁的数据对象select t2.username, t2.sid, t2.serial#, t2.logon_time from v$locked_object t1, v$session t2where t1.session_id = t2.sidorder by t2.logon_time; 执行上述语句后，得到如下的结果： 表明的确是有用户的数据对象（因为当前数据库实例中只有图中的用户处于活动状态）处于锁定状态，然后需要把该用户的进程kill掉即可。 停止被锁事务数据对象的进程123--同一个sid可能会被不同的session使用，所以通过sid和serial number可以唯一定位；--下面的sid，和serial#替换成上图中对应的值即可alter system kill session 'sid,serial#'; 其实，上面的截图只是一部分，总共有27个被锁的数据对象，如果一行一行进行kill，岂不烦死本宝宝，因此我使用存储过程来实现了： 1234567891011121314151617declare cursor kill_lockedobj_crs is( select t2.sid,t2.serial# serial from v$locked_object t1,v$session t2 where t1.session_id=t2.sid ); v_sql varchar2(500); v_session varchar2(30);begin for cont in kill_lockedobj_crs loop exit when kill_lockedobj_crs%notfound; v_obj := cont.sid ||&apos;,&apos;||cont.serial; v_sql := &apos;alter system kill session&apos; || v_obj; execute immediate v_sql; end loop;end;/commit; 望我的解决方法对大家有所帮助。如有错误，欢迎指正和交流！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL数据库备份和恢复]]></title>
      <url>%2F2016%2F03%2F31%2Fmysqldb-dump-and-import%2F</url>
      <content type="text"><![CDATA[如果你需要将数据拷贝至其他的 MySQL 服务器上, 你可以在 mysqldump 命令中指定数据库名及数据表。 在源主机上执行以下命令，将数据备份至 dump.txt 文件中: 12$ mysqldump -u root -p database_name table_name &gt; dump.txtpassword ***** 如果完整备份数据库，则无需使用特定的表名称如果你需要将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建： 12$ mysql -u root -p database_name &lt; dump.txtpassword *****]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记（三）]]></title>
      <url>%2F2016%2F03%2F16%2Funderstanding-the-JVM-2nd-edition-3%2F</url>
      <content type="text"><![CDATA[虚拟机把描述类数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机识别的Java类型，这就是Java虚拟机的类加载机制，并且类型的加载、链接和初始化都是在程序运行期间完成的，这篇文章就来谈谈类加载机制。 虚拟机把描述类数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机识别的Java类型，这就是Java虚拟机的类加载机制，并且类型的加载、链接和初始化都是在程序运行期间完成的，这篇文章就来谈谈类加载机制。 类加载的时机 类从加载到虚拟机内存开始，到卸载出内存为止，类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载等7个阶段。其中验证、准备、解析阶段称为链接。类的生命周期如图： ​ 图中的加载、验证、准备、初始化和卸载等几个阶段是确定的，而解析这个阶段并不确定。 虚拟机规范严格规定了有且只有5种情况下必须对类进行“初始化”： 使用new关键字示例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候； 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化； 当初始化一个类时，若其父类还没有初始化则需要先触发其父类的初始化； 当虚拟机启动时，用户需要指定一个要执行的主类（包含mian()的方法的那个类），虚拟机会先初始化这个主类； 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_in-vokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 上面5种情况称为对一个类进行主动引用。除此之外的所有引用类都不会触发初始化，称为被动引用。下面是对被动引用的演示代码： 12345678910111213141516171819202122232425262728293031323334public class SuperClass&#123; static&#123; System.out.println("SuperClass init!"); &#125; public static int = 123;&#125;public class SubClass extends SuperClass&#123; static&#123; System.out.println("SubClass init!"); &#125;&#125;public class ConstClass&#123; public static final String HELLOWORLD = "Hello world"; static&#123; System.out.println("ConstClass init!"); &#125;&#125;public class NotInitialization&#123; public static void main(String[] args)&#123; //通过子类引用父类的静态字段，不会导致子类初始化，因为对于静态字段只有定义这个字段的类才会初始化 System.out.println(SuperClass.value); //通过数组定义来引用类，不会触发该类的初始化 SuperClass[] sca = new SuperClass[10]; //常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会触发该类的初始化 System.out.println(ConstClass.HELLOWORLD); &#125;&#125; Java虚拟机中类加载的过程包括加载、验证、准备、解析和初始化这5个阶段： 加载阶段，虚拟机需要完成的事情： 通过一个类的全限定名获得定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口。 数组类本身不通过类加载器创建，而是由Java虚拟机直接创建。 验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。大体上，验证阶段会完成文件格式、元数据、字节码和符号引用等验证； 准备阶段是正式为类变量分配内存（此时内存分配仅包括类变量——被static修饰的变量，实例变量将会随着对象一起分配在Java堆中）并设置类变量初始值（即数据类型的零值，当然ConstantValue属性会设置为指定的值）的阶段； 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的的过程； 初始化阶段真正执行类中定义的Java程序代码，并执行类构造器&lt;clinit&gt;()方法，按照程序初始化类和其他资源。 类加载器 实现”通过一个类的全限定名获得定义此类的二进制字节流”这个动作的代码模块成为”类加载器“； 一个类在Java虚拟机中的唯一性需要由这个类本身和加载该类的类加载器共同决定，即比较两个类是否相等的前提是这两个类由同一个类加载器加载。这里的”相等“，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回的结果，也包括使用instanceof关键字做对象所属关系判定情况； 从Java虚拟机的角度讲，只存在两种不同的类加载器：启动类加载器，这个类加载器由C++语言实现，是虚拟机的一部分；另一种是是所有其他类加载器，由Java语言实现，并且独立于虚拟机外部； 从Java程序员的角度来看，类加载器可以分为如下3类： 启动类加载器（Bootstrap ClassLoader）：是用本地代码实现的类装入器，它负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作； 标准扩展类加载器（Extension ClassLoader）：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器； 应用程序类加载器（Application ClassLoader）：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将用户类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()返回值，所以也成为系统类加载器。 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。这就是双亲委派机制。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oracle数据库表的备份及还原]]></title>
      <url>%2F2016%2F03%2F02%2Foracledb-dump-and-import%2F</url>
      <content type="text"><![CDATA[这里的Oracle数据库表的备份及还原准确得说，是指某用户下数据库表及其数据的导出和将导出的dmp文件导入新用户的过程。以下操作均在Linux命令行中进行。 以SYSDBA身份连接数据库12345--无连接启动sqlplussqlplus /nolog;--以sysdba的身份连接数据库conn /as sysdba; 创建表空间和用户12345678-- 创建表空间，table_space_datafile建议和表空间的名称保持一致CREATE TABLESPACE your_tablespace_name DATAFILE '/u00/oradata/tablespace_datafile.dbf' SIZE 128M AUTOEXTEND ON NEXT 32M MAXSIZE UNLIMITED;-- 在上述表空间下创建用户CREATE USER your_user IDENTIFIED BY your_password DEFAULT TABLESPACE your_tablespace_name;-- 赋权限给上述创建的用户GRANT CONNECT,RESOURCE,CREATE TABLE,CREATE VIEW,EXECUTE ANY PROCEDURE,CREATE SYNONYM TO your_user; 创建数据库表、索引并初始化这里指的是数据库表中数据的初始化。根据业务的不同，在表创建完成后，表中一般是要有初始数据的。下面我们将该用户下的数据表及其数据导出，以作备份。 执行导出命令12--/home/oracle/dmp/dmp_file_name.dmp为举例路径，根据实际情况指定你自己的路径exp your_user/your_password file=/home/oracle/dmp/dmp_file_name.dmp; 执行导入命令如果希望把上述的备份文件导入到新的用户，则可以创建新的表空间和用户，并执行如下命令： 12--此操作需要知道dmp文件导出用户的用户名和密码imp your_user/your_password file=/home/oracle/dmp/dmp_file_name.dmp fromuser=your_user touser=new_user; 以上即为数据库表备份和还原的一般实现过程。 Tips:用户和表空间的删除由于在开发过程中需要经常创建和删除用户，一段时间后则需要清理掉不再使用的用户和表空间。对于单个user和tablespace 来说， 可以 依次 使用如下命令来完成： 1234--此操作删除了该user下的schema objects，不会删除相应的tablespaceDROP USER your_user CASCADE;--删除表空间DROP TABLESPACE tablespace_name INCLUDING CONTENTS AND DATAFILES; 如果删除用户时出现如下报错： 123456&gt; SQL&gt; DROP USER username CASCADE;&gt; DROP USER username CASCADE&gt; *&gt; ERROR at line 1:&gt; ORA-01940: cannot drop a user that is currently connected&gt; 可以使用如下操作: 12--查看用户进程，用户名需要大写，如下图select sid, serial# from v$session where username='YOUR_USER'; 123--依次将用户占用的会话进程停止alter system kill session '1075,5234';alter system kill session '1076,4388'; 以下是删除表空间的一些其他操作方式： 1234567891011121314--删除空的表空间，但是不包含物理文件DROP TABLESPACE tablespace_name;--删除非空表空间，但是不包含物理文件DROP TABLESPACE tablespace_name INCLUDING CONTENTS;--删除空表空间，包含物理文件DROP TABLESPACE tablespace_name INCLUDING DATAFILES;--删除非空表空间，包含物理文件DROP TABLESPACE tablespace_name INCLUDING CONTENTS AND DATAFILES;--如果其他表空间中的表有外键等约束关联到了本表空间中的表的字段，就要加上CASCADE CONSTRAINTSDROP TABLESPACE tablespace_name INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在PL/SQL中自定义数组类型]]></title>
      <url>%2F2016%2F02%2F22%2Fuser-defined-array-in-plsql%2F</url>
      <content type="text"><![CDATA[知识准备定长数组12--定长数字型数组，长度为10type identifer is varray(10) of number; 如：12345678910111213set serveroutput on;declare type v_array is varray(10) of number; v_index number; v_arr v_array; v_arr := v_array(1,23,567,233,66);begin for index in 1..v_arr.count loop dbms_output.put_line(v_arr(v_index)); end loop;end;/ 变长数组12--可变长数字型数组，数组中元素长度为10，角标索引为integer自动增长type identifer is table of number(10) index by binary_integer; 如：12345678910111213set serveroutput on;declare type v_array is is table of number(10) index by binary_integer; v_index number; v_arr v_array; v_arr := v_array(1,23,567,233,66);begin for index in 1..v_arr.count loop dbms_output.put_line(v_arr(v_index)); end loop;end;/ 实战 批量更新用户的在线状态，userid 为用户id，useronline 为用户的在线状态，因用户的数量无法确定，此处采用可变长数组的定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243--为了在存储过程中可以使用自定义的数组类型，此处使用程序包的方式create or replace package useronline_pkgas type int_array is table of number(10) index by binary_integer; procedure batch_updateuseronline (v_userid in int_array, v_onlines in int_array);end useronline_pkg;/--声明程序包体create or replace package body useronline_pkgas procedure batch_updateuseronline( v_userid in int_array, v_onlines in int_array ) as user_id number(10); user_online number(1); v_index number(8); begin for v_index in 1..v_userid.count loop user_id := v_userid(v_index); user_online := v_onlines(v_index); --若用户的在线状态的记录已经存在，则只更新其在线状态；否则，则插入一条记录 merge into useronline tb using (select count(userid) as cnt from useronline where userid=user_id) tb_tmp on(tb_tmp.cnt &lt;&gt; 0) when matched then update set tb.onlines=user_online, tb.updatetime=sysdate where userid=user_id when not matched then insert values(user_id, user_online, sysdate); commit; end loop; end batch_updateuseronline;end useronline_pkg;/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记（二）]]></title>
      <url>%2F2016%2F02%2F11%2Funderstanding-the-JVM-2nd-edition-2%2F</url>
      <content type="text"><![CDATA[Java中的对象几乎全部存放在Java堆中，垃圾收集器在回收时首先要确定哪些对象是“存活”的，哪些对象已经“死去”。这篇文章介绍垃圾收集器主要关注的内存区域和在什么情况下垃圾收集器开始进行回收操作。 垃圾回收的内存区域 程序计数器、虚拟机栈和本地方法栈随线程的生灭而生灭，并且栈中的栈帧分配多少内存基本上是在类结构确定下来时就是已知的，即编译器可知，所以这几个区域就不需要考虑垃圾回收的问题了：方法或者线程结束后，内存自然就跟着回收了； Java堆和方法区这部分的内存的分配和回收都是动态的，因为只有在运行时我们才知道会创建哪些对象，所以垃圾回收器关注的是这部分内存的回收，内存分配也是指的这部分； 对象是否被引用的判断方法 引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为零的对象便是不可使用的对象，这个时候这些内存就要被回收。由于这种算法不能解决引用的“孤岛”问题——循环引用，故Java并未采取这种内存回收算法，而是下面的可达性分析算法； 可达性分析算法：这种判断一个对象是否存活的算法其实是使用了基于引用关系的树遍历，其基本的思路是通过一系列的GC Roots的对象作为起始点，从这些起始点开始向下搜索遍历，搜寻这对象所引用的其他对象，直到找不到被引用的其他对象为止，而搜索所走过的路径成为引用链，被发现的对象会被标记为存活并称之为可达的，当一个对象到GC Roots没有任何引用链时，则该对象是不可用的，成为垃圾回收器的内存回收对象，如图所示： 对象object5、object6和object7之间虽互有关联，但是他们到GC Roots是不可达的，所以会被判定为回收的对象。在Java中，可作为上文所述的GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态类型属性、常量等引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 对于在上述可达性分析算法中不可达的对象所占用内存空间并不会立即被回收，而是需要经过两次标记过程：对象在经过可达性分析后被发现没有和GC Roots关联则会被标记一次，并通过判断其是否有必要执行finalize()方法（当前对象没有覆盖此方法或者虚拟机已经调用过一次，则会判定为没必要执行），来判断是否还能继续存活；如果这个对象有必要执行finalize（）方法，则该对象将会被放入一个称为F-Queue的队列中，在这里对象可能会逃脱被回收的命运：将自己与引用链上任何一个对象建立关联即可，如把自己赋值给某个类变量或者某个对象的成员变量。如果在这里这个对象仍不逃脱，则会再次标记一次，将会真正被回收； Java中将引用分为强引用（Strong Reference）、软引用（Sfot Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），他们的引用强度一次减弱： 当在程序中使用new操作符创建一个新的对象并将其赋值给一个变量的时候，这个变量就成为了指向该对象的一个强引用，只要强引用还存在，垃圾回收器则永远不会回收该对象； 软引用用来描述一些还有用但非必需的对象。对于软引用关联着的对象，只有在系统将要发生内存溢出异常之前，才会将这些对象列进回收范围之内进行第二次回收； 被软引用关联的对象只能生存到下次垃圾收集时，并且无论当时内存是否足够，都会把若引用关联的对象回收掉； 虚引用的存在不会对对象的生存时间构成影响，其存在的唯一目的是其关联的对象在被垃圾收集器回收时收到系统通知。 方法区的垃圾回收主要回收两部分内容：废弃常量和无用类。如果进入常量池的某个常量没有被任何对象引用，也没有任何其他地方使用了此字面量，如果此时发生了必要的内存回收，那这个常量就会被系统清理出常量池。常量池中的其他类（接口）、方法和字段的符号应用也与此类似；判定一个无用类需要同时满足下面3个条件： 该类的所有实例已经被回收，即Java堆中不存在该类的实例； 加载该类的ClassLoader已经被回收； 该类对象的Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux下Oracle服务的开启和关闭]]></title>
      <url>%2F2016%2F01%2F25%2FLinux-OracleDB-service-startup-and-sutdown%2F</url>
      <content type="text"><![CDATA[在平时的工作中时而会碰到机房停电，这时我们开发中使用的Oracle数据所在服务器也会关机。这个时候就需要来手动开启Oracle服务，现在作如下总结： Linux下启动Oracle12345678910111213--切换到oracle用户su - oracle--无连接启动sqlplus，并以sysdba的身份登录到数据库sqlplus /nologconn /as sysdba--开启Oracle数据库实例startup--退出sqlplusexit--启动监听器lsnrctl start--退出Oracle用户exit Linux下关闭Oracle123456789su - oraclesqlplus /nologconn /as sysdba--关闭Oracle实例shutdown immediateexit--关闭监听器lsnrctl stopexit Linux下查看监听器状态12345678--切换到Oracle用户su - oraclelsnrctl--查看监听器状态statusexit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记（一）]]></title>
      <url>%2F2016%2F01%2F18%2Funderstanding-the-JVM-2nd-edition-1%2F</url>
      <content type="text"><![CDATA[有关Java虚拟机的这一系列文章都基于《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书，是在阅读这本书过程的一些读书笔记，以梳理和总结相关的知识点为目的。 运行时数据区域 Java虚拟机在执行Java程序时，会将把其所管理的内存分为若干个数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（JavaSE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器、虚拟机栈、Java堆、方法区和本地方法栈。如下图所示： 程序计数器（Program Counter Resgister）：是一块较小的内存区域，可以看作是当前线程执行字节码的行号指示器（实际是当执行字节码的地址），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。该区域是线程私有的； 虚拟机栈（VM Stack）：是Java方法执行的内存模型，每个Java方法（或本地方法）在执行的同时会创建栈帧（Stack Frame），用来存放局部变量表、方法出口、操作数栈和动态链接等信息。每个方法从调用到执行完成的过程就对应着这样一个栈帧的入栈和弹栈。局部变量表所需的内存大小在编译期就已分配完成，进入一个方法或方法在执行过程中，其大小是确定的，不变的。Sun Hotspot虚拟机中，Java虚拟机栈和本地方法栈（为Native方法服务）合二为一，此处统称为虚拟机栈。该区域是线程私有的； Java堆（Java Heap）：是Java虚拟机所管理内存中最大的一块区域，并且被各线程共享，在虚拟机启动时被创建。此区域唯一目的就是存放对象实例和数组，同时也是GC管理的主要区域。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样； 方法区（Method Area）：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范把方法区描述为堆的一个逻辑部分，亦称“非堆（Non-Heap）”。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 HotSpot VM下堆内存的对象管理 对象的创建：此处讨论的对象仅限于普通Java对象，不包括数组和Class对象等。下面是Java对象创建的过程： 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程； 类加载检查通过后，会为对象分配内存。根据Java堆是否规整，为对象分配空间的方式有“指针碰撞”和“空闲列表”之分。由于Java堆是各个线程共享的一片内存区域，则在给对象分配空间时存在线程不安全的问题，为解决这个问题可以采用CAS配上失败重试的方式保证更新操作的原子性或者采用本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）方式为每个线程预先分配一小块内存，然后在这小块内存上为对象分配空间。内存的大小是在类加载完就可以确定的（至于为什么之后再补充）； 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。这一操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值； 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头（ObjectHeader）之中； 一般来说，执行new指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局：dui在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。下面分别介绍着3块区域： HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例； 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来； 对齐填充仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位：Java程序需要通过栈上的reference数据来操作访问堆上的具体对象，目前主流的访问方式有使用句柄和直接指针两种； 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图： 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如图： 对虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，即通过直接指针访问对象。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。]]></content>
    </entry>

    
  
  
</search>
